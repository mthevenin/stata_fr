{
  "hash": "d11a6b349b38c3f8fa5e82d29e98fc70",
  "result": {
    "markdown": "---\ntitle: \"**Visualisation des densités avec gridge**\"\n\ntitle-block-banner: false\n\ncategories:\n  - graphique\n  - ado\n\nauthor: \n  - name: \"Marc Thévenin\"\n    affiliations:\n      - name: \"Ined\"\n\ndate: 09/26/2022\n\nformat: \n  html: default\n  docx:\n    toc: true\n    number-sections: true\n\nfilters:\n   - lightbox\nlightbox: auto\n\nabstract: |\n Depuis 2020, des programmes permettent de générer de type lignes de crête: `joyplot` (A.Naqvi) et `joy_plot` (F.Rios-Avila). A partir d'un programme écrit à l'automne 2020, et en restant au plus près de la fonction `ggridge` de R, j'ai également (et modestement) programmé une commande. \n\n---\n\n\nLa commande `gridge` permet, entre autres, de contrôler le tri les modalités de l'axe discret à partir d'une fonction autorisée avec `egen` (*mean*, *median*, *sd*....), de choisir librement un intervalle sur l'axe des abscisses pour éviter le report de valeurs sortant d'une borne acceptable (probabilité négatives ou supérieure à 1 dans l'exemple). Comme  on estime des densités, le nombre d'observations minimales a été fixé à 10. Si ce critère n'est pas respecté, les valeurs de y en cause  sont affichées.  Des améliorations restent néanmoins à prévoir.\n\n# Installation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnet install gridge, from(\"https://raw.githubusercontent.com/mthevenin/stata_graphiques/master/ressources/gridge/\") replace\n```\n:::\n\n\n# Syntaxe\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsyntax variable [if],                                                                ///\nover(variable)  super(numeric 1.8)                                                   ///\nsort(string)  sortrev(string) bw(real>0 1.5)                                         ///\npalette(string) colrev opac(integer 80)  lc(integer 2)] lw(real .5)] gopts(string)]  ///   \nrange(value1 value2)   \n```\n:::\n\n\n*Entre parenthèse le type d'argument, suivi si nécessaire de la valeur par défaut.* \n\n**Arguments**  \n\n- `over(variable)`: variable de stratification. De type numérique avec ou non un label\n- `super(numeric 1.8)`: degré de superposition des densités. Positif de préférence.\n- `sort(string)`: **mean**, **median**, **sd**, **iqr**, **mode** (ou autre fonction statistique compatible avec `egen`)\n- `sortrev(string)` - `sortr(string)`: idem mais les valeurs de la variable `over()` seront affichées en ordre décroissant\n- `bw(real>0 1.5)`: largeur de la fenêtre de lissage.\n- `palette(string)`  `pal(string)`: nom d'une palette du package `colorpalette`. Ce dernier sera installé comme dépendance si nécessaire. L'ordre des couleurs sera inversé par rapport à palette sélectionnée. \n- `colrev`: permet d'inverser l'ordre des couleurs de la palette. Permet de retrouvet l'ordre de la palette d'origine de `colorpalette`\n- `opac(integer 80)`: % d'opacité des couleurs. Valeur max = 100\n- `range(value1 value2)`: permet de borner les valeurs de l'axe continu (x). value1 $<$ value2\n-  `lc(integer 2)`: échelle de gris du contour des densités (palette **gs**). Valeurs comprise entre 1 (noir) et 15 (blanc)\n- `lw(real .5)`: épaisseur du contour des densités en valeur relative. Valeur minimum 0\n- `gopts(string)`: autres options des graphique de type `tw`: titre, xlabel, plotr, graphr.... **Ne pas utiliser l'option `ylabel`** (option spécifique à venir).            \n\n**Remarques**  \n\n- Pour la variable de l'argument `over()`, chaque valeur doivent avoir au moins 10 observations. Si ce n'est pas le cas, la commande n'exécutera pas le graphique mais affichera les valeurs dont le nombre d'observation est insuffisant.\n- Toujours pour la variable de l'argument `over()`, j'ai pour l'instant limité le format de la variable à un format numérique, avec ou sans labels affectés aux valeurs.\n- Ce type de visualisation est également utilisée pour représenter comparer l'évolution dans le temps d'une variable quantitative, par exemple entre pays (très à la mode avec le COVID)[exemple](https://www.ined.fr/fichier/rte/166/Page%20accueil/SDR_plot_all_countries_fr.jpg). Cela permet d'offrir un certain contrôle des effets dits \"spaghetti\", mais je préfère dans ce cadre les approches de type *small-multiple*. Par ailleurs, dans l'esprit des courbes de Ridge, l'axe Y est plutôt de type ordonné. Cette option est offerte dans la fonction `joyplot` (A.Navqui).\n\n                                                                                             \n# Exemples\n\n## Exemple 1\n\n***Ouverture de la base***\n\n::: {.cell}\n\n```{.r .cell-code}\nwebuse set  \"https://raw.githubusercontent.com//mthevenin/stata_graphiques/master/ressources/gridge\"\nwebuse \"probability.dta\", clear\nwebuse set\n```\n:::\n\n  \n  \n***Graphique***\n\n::: {.cell}\n\n```{.r .cell-code}\n#delimit;\ngridge p , over(proba) \nrange(0 100) bw(2) \npalette(flare) op(90)\n\ngopts(title(\"Probabilités assignées\", pos(11))\ncaption(\"Source: Reddit\", size(*.5)) \nxtitle(\"probabilités (%)\")) \n;\n```\n:::\n\n\n![](g1.png){width=70%}\n\n## Exemple 2\n\nDans le premier exemple, les modalités de l'axe discret était ordonnée. Avec cet exemple, Le premier graphique représente la série de distributions suivant l'ordre des valeurs par défaut de la variable *zône*. Le second graphique avec l'option `sort(median)` trie de manière croissante les secteurs selon la valeur médiane du prix de la location, enfin le troisième applique un tri décroissant avec l'option `sortrev(median)`.  \n\n***Ouverture de la base***\n\n::: {.cell}\n\n```{.r .cell-code}\nwebuse set https://github.com/mthevenin/stata_graphiques/tree/main/bases\nuse rbnb_paris, replace\nwebuse set\n```\n:::\n\n\n***Graphique 1***\n\n::: {.cell}\n\n```{.r .cell-code}\ngridge price if price<=300, over(zone) bw(4) gopts(title(\"Prix location Rbnb à Paris\", pos(11))) range(0 300)\n```\n:::\n\n\n***Graphique 2***\n\n::: {.cell}\n\n```{.r .cell-code}\n#delimit ;\ngridge price, \nover(zone)  super(2) palette(HCL heat2) bw(4) lc(2) lw(.8) sort(mean)\ngopts(title(\"Prix location Rbnb à Paris\", pos(11))) range(0 300) op(100)\n;\n```\n:::\n\n\n![](g2.png){width=70%}\n\n***Graphique 3***\n\n::: {.cell}\n\n```{.r .cell-code}\n#delimit ;\ngridge price, \nover(zone)  super(2) palette(HCL heat2) bw(4) lc(2) lw(.8) sortrev(mean) colrev\ngopts(title(\"Prix location Rbnb à Paris\", pos(11)))\n;\n```\n:::\n\n\n![](g3.png){width=70%}\n\n# Nombre d'observations insuffisantes pour estimer les densités\n\nLe seuil à été fixé à 10 observations. Si ce n'est pas le cas, le graphique n'est pas exécuté mais les informations sur les valeurs de y qui manquent d'informations sont indiquées\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwebuse nhanes2, clear\n\ngen bmi2 = round(bmi)\ngridge bpsystol, over(bmi2)\n\n/*\nbmi2=12: nombre d'observations insuffisant pour estimer les densités\nbmi2=14: nombre d'observations insuffisant pour estimer les densités\nbmi2=15: nombre d'observations insuffisant pour estimer les densités\nbmi2=46: nombre d'observations insuffisant pour estimer les densités\nbmi2=47: nombre d'observations insuffisant pour estimer les densités\nbmi2=48: nombre d'observations insuffisant pour estimer les densités\nbmi2=49: nombre d'observations insuffisant pour estimer les densités\nbmi2=51: nombre d'observations insuffisant pour estimer les densités\nbmi2=52: nombre d'observations insuffisant pour estimer les densités\nbmi2=53: nombre d'observations insuffisant pour estimer les densités\nbmi2=54: nombre d'observations insuffisant pour estimer les densités\nbmi2=55: nombre d'observations insuffisant pour estimer les densités\nbmi2=57: nombre d'observations insuffisant pour estimer les densités\nbmi2=61: nombre d'observations insuffisant pour estimer les densités\n Exit: nombre d'observations minimum = 10\n */\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}