{
  "hash": "6ba09e10e538ffff7f2a1184b2ba8242",
  "result": {
    "markdown": "---\ntitle: \"**Améliorer la durée d'exécution avec Gtools**\"\n\ntitle-block-banner: false\n\nauthor: \n  - name: \"Marc Thévenin\"\n    affiliations:\n      - name: \"Ined\"\n\ndate: 02/23/2023\n\ncategories:\n  - gtools\n  - runtime\n\nformat: \n  html: default\n  docx:\n    toc: true\n    number-sections: true\n\nfilters:\n   - lightbox\nlightbox: auto\n\nabstract: | \n Le package **`gtools`** de Mauricio Caceres Bravo permet d'améliorer significativement la durée d'exécution pour un certain nombre d'opérations, en particulier les transpositions de bases (`reshape`). Les éléments qui suivent proposent des éléments de benchmark avec les commandes usines et des fonctions équivalentes sous R. \n\n---\n\n\n\n\n\n<br>\n![](succssrocket.gif){width=\"10%\"}  \n\n- Stata 17: grosse amélioration du temps d'exécution de certaines commandes, en particulier **`sort`** et **`collapse`**. \n- Depuis de nombreuses années des packages ou commandes standalone amélioraientt le temps d'exécution, en particulier les packages **`ftools`** de *Sergio Correa* ou les commandes `fastxtile`/`fastwpctile` d'**`egenmisc`**.\n- Le package **`gtools`** de *Mauricio Caceres Bravo* donne des résultats vraiment très intéressants lorsqu'on atteint un seuil d'un million d'observations pour les commandes suivantes: `greshape`, `gquantiles`, `gegen`, `glevelof` avec une variable caractère, et dans une moindre mesure `gcollapse`.\n- Au delà des durées d'exécution, ces packages et commandes peuvent avoir quelques options propres, par exemple, l'option `by()` de *`gquantiles`* ou la possibilité d'enregistrer les valeurs en ordre décroissant avec `glevelsof`.\n\n\n**Benchmarks**  \n\n- Version Stata 17 SE. Les benchmarks réalisés par *Mauricio Caceres* sont en version MP.\n- Configuration PC:  i5-10210U CPU et 16GO de RAM.\n- Volumétries: 10k, 100k, 1M, 10M.\n- Comparaisons avec R si fonctions équivalentes.\n- Programme Stata: [programme](programme.do)\n- To do: faire les tests sur la version serveur-linux (toujours Stata 17 SE) \n\n**Sources**:\n\n- **Stata 17 faster**: <https://www.stata.com/new-in-stata/faster-stata-speed-improvements/>\n- **ftools**: <https://github.com/sergiocorreia/ftools>\n- **gtools**: \n  - <https://gtools.readthedocs.io/en/latest/index.html>\n  - <https://github.com/mcaceresb/stata-gtools>         \n\n\n\n# **Le package**\n\nAuteur: ***Mauricio Caceres Bravo***\n\n***Installation***:\n\n-   <https://gtools.readthedocs.io/en/latest/index.html>\n-   <https://github.com/mcaceresb/stata-gtools>\n\nLes Benchmarks réalisés par l'auteur ont été exécutés avec Stata MP. J'ai fait tourné son programme ([lien](https://raw.githubusercontent.com/mcaceresb/stata-gtools/master/docs/benchmarks/quick.do)) avec Stata 17 SE sous windows. Les résultats sont les suivants:\n\n\n::: {.cell}\n\n```{.stata .cell-code}\n     Versus | Native | gtools | % faster \n ---------- | ------ | ------ | -------- \n   collapse |   1.53 |   1.25 |   18.51% \n   collapse |   1.68 |   1.17 |   29.91% \n    reshape |  31.63 |   6.90 |   78.19% \n    reshape |  60.26 |  10.95 |   81.83% \n      xtile |  17.74 |   1.12 |   93.67% \n     pctile |  18.20 |   0.77 |   95.76% \n       egen |   2.13 |   0.64 |   69.77% \n   contract |   4.52 |   1.74 |   61.54% \n       isid |  18.71 |   0.68 |   96.35% \n duplicates |  10.07 |   0.86 |   91.42% \n   levelsof |   2.75 |   0.44 |   83.94% \n   distinct |   7.24 |   0.44 |   93.88% \n     winsor |  16.09 |   0.65 |   95.99% \n sum_detail |  17.09 |   1.22 |   92.86% \n    tabstat |  11.18 |   0.67 |   94.03% \n range_stat |  67.37 |   2.82 |   95.81% \n```\n:::\n\n\nPour mon propre benchmark, plus gourmand (10 variables quanti et une variable binaire), les données sont générées de la manière suivante:\n\n**Création de la base de données (N=10M)**\n\n\n::: {.cell}\n\n```{.stata .cell-code}\nclear \nset obs 10000000\ntempvar x\ngen `x' = runiform()\ngen g = `x'>.5\n\nforv i=1/10 {\ngen y`i' = rnormal()\t\n\t\ngen id = _n\t\n}\n```\n:::\n\n\nPour récupérer les durées d'exécution, j'utilise un fragment du programme de *M.Caceres*. Les commandes sont exécutées avec le prefixe `bench 1:`\n\n\n::: {.cell}\n\n```{.stata .cell-code}\ncapture program drop bench\nprogram bench\n    gettoken timer call: 0,    p(:)\n    gettoken colon call: call, p(:)\n    cap timer clear `timer'\n    timer on `timer'\n    `call'\n    timer off `timer'\n    qui timer list\n    c_local r`timer' `=r(t`timer')'\nend\n```\n:::\n\n\n- Les tests sont réalisés avec les équivalents de `xtile`, `reshape`, `collapse`et `levelsof`. L'équivalent à `tabstat` sera ajouté rapidement.\n- Pour information, les programmes des fonctions R sont également rapidement décris. Les durées d'exécution ont été récupérés avec la librairie `tictoc`.\n\n\n# **gquantiles**\n\n-   Commande usine `xtile` et `pctile` (`help xtile`). Le benchmark est seulement effectué pour `xtile` (affectation d'un quantile à une valeur) qui est plus gourmant que `pctile` (calcul et report des quantiles).\n\n-   En termes d'options, l'autre intérêt de **`gquantile`** est de stratifier l'opération avec l'option `by()`.\n\n***Syntaxe courte***\n\n\n::: {.cell}\n\n```{.stata .cell-code}\n\n*xtile\ngquantiles nouvelle_var = var1 , xtile  nq(#) [by(var2)]\n\n*pctile\ngquantiles nouvelle_var = var1 , pctile nq(#) [by(var2)] \n```\n:::\n\n\n***Programme***\n\n\n::: {.cell}\n\n```{.stata .cell-code}\n* Fonction bench (voir plus haut)\n\nqui forv i=1/10 {\n  \n** XTILE\n  \ntempvar yg`i'\nbench 1:   xtile `yg`i'' = y`i' ,  nq(10) \nlocal rt1 = `rt1' + `r1' \n  }\ndi \"XTILE runtime =\" `rt1'\n\n*** GQUANTILES\nqui forv i=1/10 {\ncapt drop  `yg`i''\t\ntempvar yg`i'\nbench 1: gquantiles `yg`i'' = y`i' , xtile  nq(10) \nlocal rt2 = `rt2' + `r1'     \n   }\ndi  \"GQUANTILES runtime =\" `rt2'\n\n```\n:::\n\n\n***Résultats*** (secondes) \n\n| Stata          | 10k  | 100k | 1M    | 10M    |\n|----------------|------|------|-------|--------|\n| xtile          | 0.12 | 1.65 | 16.03 | 196.56 |\n| **gquantiles** | 0.06 | 0.22 | 1.24  | 14.75  |\n\n| R        | 10k  | 100k | 1M   | 10M   |\n|----------|------|------|------|-------|\n| quantcut | 0.04 | 0.24 | 2.38 | 29.11 |\n| ntile    | 0.06 | 0.16 | 1.54 | 15.51 |\n\n  \n\n::: {.callout-note icon=\"false\"}\n## Fonctions R\n\n-   **`quantcut`**\n    -   librairie `gtools`\n    -   Syntaxe pour la variable y1: **`df$gy1=quantcut(df$y1,10)`**\n-   **`ntile`**\n    -   librairie `dplyr`\n    -   Syntaxe pour la variable y1: **`df=df %>% mutate(gy1 = ntile(y1, 10))`**\n:::\n\n  \n  \n# **greshape**\n\n* Niveau syntaxe peu de différence avec la commande usine, si ce n'est pour les arguments `i()` et `j()`\n  * `i()` = `id()`\n  * `j()` = `key()`\n* Pour R: \n  * Fonction de base `reshape`. \n    * Avantage: syntaxe très proche de Stata\n    * Inconvénients: temps d'exécution pas optimal. Pour 10M d'observations, j'ai arrêté l'exécution au bout de 10 minutes.\n  * Fonctions `pivot_longer` et `pivot_wider` de **`tydir`. \n  \nSi **`greshape`** est nettement plus performant que **`reshape`**, il reste nettement en deçà des deux fonctions de la librairie **`tydir`** de R.  \n  \n\n***Programme***\n\n\n::: {.cell}\n\n```{.stata .cell-code}\n* Fonction bench (voir plus haut)\n\n**RESHAPE\nqui bench 1: reshape long y, i(id) j(j)\ndi \"RESHAPE LONG runtime =\" `r1'\nqui bench 1: reshape wide y, i(id) j(j)\ndi \"RESHAPE WIDE runtime =\" `r1'\n\n**GRESHAPE\nqui bench 1: greshape long y, by(id) keys(j)\ndi \"GRESHAPE LONG runtime =\" `r1'\nqui bench 1: greshape wide y, by(id) keys(j)\ndi \"GRESHAPE WIDE runtime =\" `r1'\n```\n:::\n\n\n***Résultats*** (secondes)\n\n::: panel-tabset\n## **Long**\n\n| Stata            | 10K  | 100k | 1M    | 10M  |\n|------------------|------|------|-------|------|\n| reshape long     | 0.14 |1.22  |12.36  |245.18|\n| **greshape long**| 0.04 |0.21  | 3.22  | 61.23|\n\n| R                | 10k  | 100k | 1M    | 10M  |\n|------------------|------|------|-------|------|\n| reshape          |  0.1 | 1.19 | 11.9  | ///  |\n| pivot_longer     |  0.01|0.12  |  0.6  | 13.39|\n\n\n\n\n## **Wide**\n\n\n| Stata            | 10k  | 100k | 1M    | 10M   |\n|------------------|------|------|-------|-------|\n| reshape wide     | 0.37 |2.18  |26.58  |338.10 |\n| **greshape wide**| 0.06 |0.30  | 2.79  | 55.86 |\n\n| R                | 10k  | 100k | 1M    | 10M  |\n|------------------|------|------|-------|------|\n| reshape          | 0.37 | 3.69 | 34.93 | ///  |\n| pivot_wider      | 0.01 | 0.24 |  1.98 | 38.97|\n\n\n:::\n\n::: {.callout-note icon=\"false\"}\n## Fonctions R\n\n-   **`reshape`**\n    -   Installé avec R\n    -   Long: `long = reshape(gtools, idvar = \"id\", timevar=\"j\", varying = list(2:11), v.names = \"y\", direction = \"long\")`\n    -   Wide: `wide = reshape(long, idvar = \"id\",  timevar=\"j\",  v.names = \"y\", sep = \"\", direction = \"wide\")`\n-   **`pivot_longer/pivot_wider`**\n    -   librairie `tydir`\n    -   long: `long = pivot_longer(gtools, cols = starts_with(\"y\")) `\n    -   wide: `wide = pivot_wider(long, names_from = c(\"name\"), values_from = c(\"value\"))`\n:::\n\n\n# **gcollapse**\n\n- Syntaxe identique à celle de `collapse`. Par défaut, c'est également la moyenne qui est calculée.\n- Ajout d'une option `merge` `replace` qui remplace la valeur des observations par l'indicateur séléctionné.\n- On ajouté l'option `by()` sur la variable g (deux groupes).\n\n\n***Programme*** \n\n\n::: {.cell}\n\n```{.stata .cell-code}\n\n*** COLLAPSE\npreserve\nqui bench 1: collapse  y1-y10,  by(g)\nlocal col `r1'\nrestore\n\n*** GCOLLAPSE\npreserve\nqui bench 1: gcollapse  y1-y10,  by(g)\nlocal gcol `r1' \nrestore\n\ndi \"N=`N\"\ndi \"COLLAPSEruntime =\" `col'\ndi \"GCOLLAPSEruntime =\" `gcol'\n```\n:::\n\n\n\n***Résultats*** (secondes)\n\n| Stata         | 10K   | 100K  | 1M    | 10 M  |\n|---------------|-------|-------|-------|-------|\n| collapse      | 0.007 | 0.041 | 0.461 | 7.846 |\n| **gcollapse** | 0.021 | 0.049 | 0.219 | 2.559 |\n| **R**         | **10K**   | **100K**  | **1M** | **10 M**  |\n| summarise     | 0.03  | 0.06  | 0.3   | 1.91  |\n\n\n*Note*: pour Stata le programme exécute `preserve`/`restore`, ce qui augmente légèrement un temps d'exécution  \n\n::: {.callout-note icon=\"false\"}\n## Fonction R\n-   **`summarise()`** \n    -   librairie `dplyr`\n    -   Syntaxe : **`collapse= gtools %>%  group_by(g) %>%  summarise(across(y1:y10, ~ mean(.x, na.rm = TRUE)))`**\n:::    \n\n***Programme*** \n\n\n# **gegen**\n\n- Syntaxe identique à celle d'`egen`. On a choisi comme fonction la moyenne.\n- On ajouté l'option `by()` sur la variable g (deux groupes).\n\n\n\n::: {.cell}\n\n```{.stata .cell-code}\nforv  i=1/10 {\nqui bench 1: egen my`i' = mean(y`i'), by(g)\nlocal egen = `egen' + `r1' \n}\n\ndrop my*\n\nforv  i=1/10 {\nqui bench 1: gegen my`i' = mean(y`i'), by(g)\nlocal gegen = `gegen' + `r1' \n}\n\ndi \"N=`N\"\ndi \"EGEN  runtime =\" `egen'\ndi \"GEGEN runtime =\" `gegen'\n```\n:::\n\n\n\n\n| Stata         | 10k  | 100k | 1M   | 10M  |\n|---------------|------|------|------|------|\n| egen          | 0.23 | 0.41 | 4.82 | 73.6 |\n| **gegen**     | 0.69 | 0.20 | 0.83 | 8.88 |\n| **R**             | **10k**  | **100k** | **1M**   | **10M**  |\n| mutate + mean | 0.03 | 0.05 | 0.17 | 1.74 |\n\n\n::: {.callout-note icon=\"false\"}\n## Fonction R\n-   **`mutate()`** associée à la fonction `mean`\n    -   librairie `dplyr`\n    -   Syntaxe : \n        - **`var <- c(\"y1\", \"y2\", \"y3\", \"y4\", \"y5\", \"y6\", \"y7\", \"y8\", \"y9\", \"y10\")`**\n        - **`gtools = gtools %>% group_by(g) %>% mutate(across(var, mean, .names = \"m{col}\"))`**\n:::    \n\n\n# **glevelsof**\n\n::: {.callout-tip icon=\"false\"}\n## Rappel\n\n- La commande **`levelsof`** (`help levelsof`) permet de récupérer automatiquement les valeurs d'une variable pour les transformer sous forme de macro. Par défaut la macro enregistrée est nommée `r(levels)`, il est possible de l'appeler différemment avec l'option `local()`. Elle est particulièrement utile en amont d'une opération en boucle de type `foreach`. La macro générée `r(r)` permet de récupérer le nombre de valeurs enregistrés, et peut donc être utile pour des instructions en boucle de type `forvalue` (et évite de programmer une macro avec la fonction `word count` plus loin). \n- Les valeurs sont enregistrées par ordre croissant numérique ou alphabétique selon le type de variable.\n:::\n\n**`glevelsof`** \n\n-  Autorise plusieurs variables. la macro enregistrée concaténera les valeurs et/ou expression avec un séparateur (espace par défaut).\n- Permet de trier les valeurs en ordre décroissant en ajoutant **-** devant le nom de la variable.\n\n\n**benchmark**  \n\n- Bien évidemment, pas de comparaison possible avec R \n- Programme d'origine différent: on va générer une variable qui affecte aléatoirement une lettre de l'alphabet (une version caractère et une version numérique générée avec `encode`). Le programme a été écrit par *Paul Picard* sur le forum *Statalist* ([lien](https://www.statalist.org/forums/forum/general-stata-discussion/general/1421124-generate-random-strings-containing-letters-and-numbers)) \n\n\n::: {.cell}\n\n```{.stata .cell-code}\nclear\nset obs 10000\nlocal c2use ABCDEFGHIJKLMNPQRSTUVWXYZ\ngen random_string = substr(\"`c2use'\", runiformint(1,length(\"`c2use'\")),1) + ///\n    string(runiformint(0,9)) + ///\n    char(runiformint(65,90)) + ///\n    char(runiformint(65,90)) + ///\n    string(runiformint(0,9)) + ///\n    char(runiformint(65,90))\n\ngen xchar = substr(random_string,1,1)\nencode xchar, gen(xnum)\ndrop random_string\n```\n:::\n\n\nLevelsof :\n\n::: {.cell}\n\n```{.stata .cell-code}\nlevelsof xchar\n\n/*\n`\"A\"' `\"B\"' `\"C\"' `\"D\"' `\"E\"' `\"F\"' `\"G\"' `\"H\"' `\"I\"' `\"J\"' `\"K\"' `\"L\"' `\"M\"' `\"N\"' `\"P\"' `\"Q\"' `\n> \"R\"' `\"S\"' `\"T\"' `\"U\"' `\"V\"' `\"W\"' `\"X\"' `\"Y\"' `\"Z\"'\n*/\n\nlevelsof xnum\n\n/*\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n*/\n\n```\n:::\n\n\nGlevelsof avec valeurs enregistrées en ordre décroissant:\n\n\n::: {.cell}\n\n```{.stata .cell-code}\nglevelsof -xchar\n\n`\"Z\"' `\"Y\"' `\"X\"' `\"W\"' `\"V\"' `\"U\"' `\"T\"' `\"S\"' `\"R\"' `\"Q\"' `\"P\"' `\"N\"' `\"M\"' `\"L\"' `\"K\"' `\"J\"' \n` \"I\"' `\"H\"' `\"G\"' `\"F\"' `\"E\"' `\"D\"' `\"C\"' `\"B\"' `\"A\"'\n\nglevelsof -xnum\n\n25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\n```\n:::\n\n\n\n| **Variable caractère** | 10k  | 100k | 1M   | 10M   |\n|------------------------|------|------|------|-------|\n| levelsof               | 0.01 | 0.10 | 2.64 | 42.51 |\n| **glevelsof**          | 0.01 | 0.01 | 0.11 | 0.62  |\n\n| **Variable numerique** | 10k  | 100k | 1M   | 10M   |\n|------------------------|------|------|------|-------|\n| levelsof               | 0.01 | 0.01 | 0.09 | 1.04  |\n| **glevelsof**          | 0.00 | 0.01 | 0.04 | 0.32  |\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}